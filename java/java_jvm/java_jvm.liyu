
一.java虚拟机

	1.JVM两个子系统，两组件：
		 Class loader(类装载)：装载class文件到Runtime data area, Native Interface
		 Execution engine(执行引擎): 执行classes中的指令
		 
		 Runtime data area(运行时数据区域): JVM内存
		 Native Interface(本地接口): 与native libraries交互，与其他编程语言交互接口
		 
	2.JVM作用步骤:
		 1.编译器把 Java 代码转换成字节码
		 2.类加载器ClassLoader再把字节码加载到JVM内存Runtime data area中
		 3.执行引擎Execution engine命令解析器，解析字节码成为底层系统指令交予CPU执行
		  过程需要调用本地库接口实现程序功能
		  
		  
	3.运行时数据区域
		 1.方法区: 被虚拟机加载的类信息，常量，静态变量，即时编译后的代码
		 2.Java堆: 对象实例化分配内存，被所有线程共享
		 3.虚拟机栈: 存储局部变量表，操作数据栈，动态链接，方法出口
		 4.本地方法栈: 与虚拟机栈作用一样，本地方法栈为虚拟机调用Native方法服务
		 5.程序计数器: 当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过
		   改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、
		   线程恢复等基础功能，都需要依赖这个计数器来完成
		   
		   
	4.堆和栈区别
		 1.堆：  分配对象不连续物理地址不连续，性能慢。
			     分配内存运行期确认，大不固定。
				 存放的内容是对象的实例和数组。
				 整个应用程序共享。
			 
		 2.栈：  分配物理地址连续，性能快。
				 内存编译器确认，大小确定。
				 存放的内容局部变量，操作数栈，返回结果。
				 线程可见，线程私有，和线程生命周期相同。
				 
		 
		 
		 3.队列和栈
				 队列: 操作名称 入队，出队。
					   队列队头入队，队尾出队，两边都可操作。
					   队列->先进先出
					   
				 栈:   操作名称 入栈，出栈。
					   栈的入栈和出栈都是在栈顶操作，栈底不可操作。
					   栈->先进后出
					   
	5.内存分配两种方式
		 指针碰撞：  Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。
					 分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，
					 这样便完成分配内存工作
		 空闲列表：	 Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，
					 这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表
					 记录			 
		
		分配内存方式由Java堆内存规整性决定，规整性又由采用垃圾收集器是否带有压缩整理功能决定。

	
	6.JVM 垃圾回收算法
		 1.标记-清除算法：标记无用对象，然后进行清除回收
		   
		   优点：(实现简单，不需要对象进行移动)
		   缺点：(效率不高，无法清除垃圾碎片)
		   
		   标记阶段：标记出可以回收的对象。
		   清除阶段：回收被标记的对象所占用的空间
		   
		   
		   
		 2.复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制
		   到另一块上，然后再把已使用的内存空间一次清理掉
		   优点：(按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片)
		   缺点：(内存使用率不高，只有原来的一半)
		   
		   
		   
		 3.标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后
		   直接清除掉端边界以外的内存
		   优点：(解决了标记-清理算法存在的内存碎片问题)
		   缺点：(仍需要进行局部对象移动，一定程度上降低了效率)
		   
		 4.分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，
		   新生代基本采用复制算法，老年代采用标记整理算法
		 
		 